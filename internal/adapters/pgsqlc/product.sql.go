// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: product.sql

package pgsqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO "product" (
    "tenant_id",
    "name",
    "sku",
    "price",
    "vat_percent",
    "is_preorder",
    "made_to_order",
    "requires_prescription",
    "available_for_delivery",
    "available_for_pickup"
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
)
RETURNING "id", "tenant_id", "name", "sku", "price", "vat_percent", "is_preorder", "made_to_order", "requires_prescription", "available_for_delivery", "available_for_pickup", "created_at", "modified_at"
`

type CreateProductParams struct {
	TenantID             uuid.UUID
	Name                 string
	Sku                  string
	Price                int64
	VatPercent           pgtype.Numeric
	IsPreorder           bool
	MadeToOrder          bool
	RequiresPrescription bool
	AvailableForDelivery bool
	AvailableForPickup   bool
}

type CreateProductRow struct {
	ID                   uuid.UUID
	TenantID             uuid.UUID
	Name                 string
	Sku                  string
	Price                int64
	VatPercent           pgtype.Numeric
	IsPreorder           bool
	MadeToOrder          bool
	RequiresPrescription bool
	AvailableForDelivery bool
	AvailableForPickup   bool
	CreatedAt            time.Time
	ModifiedAt           time.Time
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (CreateProductRow, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.TenantID,
		arg.Name,
		arg.Sku,
		arg.Price,
		arg.VatPercent,
		arg.IsPreorder,
		arg.MadeToOrder,
		arg.RequiresPrescription,
		arg.AvailableForDelivery,
		arg.AvailableForPickup,
	)
	var i CreateProductRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Sku,
		&i.Price,
		&i.VatPercent,
		&i.IsPreorder,
		&i.MadeToOrder,
		&i.RequiresPrescription,
		&i.AvailableForDelivery,
		&i.AvailableForPickup,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const getProductByTenantAndID = `-- name: GetProductByTenantAndID :one
SELECT "id", "tenant_id", "name", "sku", "price", "vat_percent", "is_preorder", "made_to_order", "requires_prescription", "available_for_delivery", "available_for_pickup", "created_at", "modified_at"
FROM "product"
WHERE "tenant_id" = $1
  AND "id" = $2
  AND "deleted_at" IS NULL
LIMIT 1
`

type GetProductByTenantAndIDParams struct {
	TenantID uuid.UUID
	ID       uuid.UUID
}

type GetProductByTenantAndIDRow struct {
	ID                   uuid.UUID
	TenantID             uuid.UUID
	Name                 string
	Sku                  string
	Price                int64
	VatPercent           pgtype.Numeric
	IsPreorder           bool
	MadeToOrder          bool
	RequiresPrescription bool
	AvailableForDelivery bool
	AvailableForPickup   bool
	CreatedAt            time.Time
	ModifiedAt           time.Time
}

func (q *Queries) GetProductByTenantAndID(ctx context.Context, arg GetProductByTenantAndIDParams) (GetProductByTenantAndIDRow, error) {
	row := q.db.QueryRow(ctx, getProductByTenantAndID, arg.TenantID, arg.ID)
	var i GetProductByTenantAndIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Sku,
		&i.Price,
		&i.VatPercent,
		&i.IsPreorder,
		&i.MadeToOrder,
		&i.RequiresPrescription,
		&i.AvailableForDelivery,
		&i.AvailableForPickup,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}
