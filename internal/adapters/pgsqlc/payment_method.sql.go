// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: payment_method.sql

package pgsqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createPaymentMethod = `-- name: CreatePaymentMethod :one
INSERT INTO "payment_method" (
    "tenant_id",
    "type",
    "label",
    "is_default"
)
VALUES (
    $1,
    $2,
    $3,
    $4
)
RETURNING "id", "tenant_id", "type", "label", "is_default", "created_at", "modified_at"
`

type CreatePaymentMethodParams struct {
	TenantID  uuid.UUID
	Type      PaymentMethodType
	Label     string
	IsDefault bool
}

type CreatePaymentMethodRow struct {
	ID         uuid.UUID
	TenantID   uuid.UUID
	Type       PaymentMethodType
	Label      string
	IsDefault  bool
	CreatedAt  time.Time
	ModifiedAt time.Time
}

func (q *Queries) CreatePaymentMethod(ctx context.Context, arg CreatePaymentMethodParams) (CreatePaymentMethodRow, error) {
	row := q.db.QueryRow(ctx, createPaymentMethod,
		arg.TenantID,
		arg.Type,
		arg.Label,
		arg.IsDefault,
	)
	var i CreatePaymentMethodRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Type,
		&i.Label,
		&i.IsDefault,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const ensureDefaultCashPaymentMethod = `-- name: EnsureDefaultCashPaymentMethod :exec
INSERT INTO "payment_method" (
    "tenant_id",
    "type",
    "label",
    "is_default"
)
VALUES (
    $1,
    'cash',
    'Cash',
    TRUE
)
ON CONFLICT DO NOTHING
`

func (q *Queries) EnsureDefaultCashPaymentMethod(ctx context.Context, tenantID uuid.UUID) error {
	_, err := q.db.Exec(ctx, ensureDefaultCashPaymentMethod, tenantID)
	return err
}

const getDefaultCashPaymentMethodByTenant = `-- name: GetDefaultCashPaymentMethodByTenant :one
SELECT "id", "tenant_id", "type", "label", "is_default", "created_at", "modified_at"
FROM "payment_method"
WHERE "tenant_id" = $1
  AND "type" = 'cash'
  AND "deleted_at" IS NULL
ORDER BY "is_default" DESC, "created_at" ASC
LIMIT 1
`

type GetDefaultCashPaymentMethodByTenantRow struct {
	ID         uuid.UUID
	TenantID   uuid.UUID
	Type       PaymentMethodType
	Label      string
	IsDefault  bool
	CreatedAt  time.Time
	ModifiedAt time.Time
}

func (q *Queries) GetDefaultCashPaymentMethodByTenant(ctx context.Context, tenantID uuid.UUID) (GetDefaultCashPaymentMethodByTenantRow, error) {
	row := q.db.QueryRow(ctx, getDefaultCashPaymentMethodByTenant, tenantID)
	var i GetDefaultCashPaymentMethodByTenantRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Type,
		&i.Label,
		&i.IsDefault,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const getPaymentMethodByTenantAndID = `-- name: GetPaymentMethodByTenantAndID :one
SELECT "id", "tenant_id", "type", "label", "is_default", "created_at", "modified_at"
FROM "payment_method"
WHERE "tenant_id" = $1
  AND "id" = $2
  AND "deleted_at" IS NULL
LIMIT 1
`

type GetPaymentMethodByTenantAndIDParams struct {
	TenantID uuid.UUID
	ID       uuid.UUID
}

type GetPaymentMethodByTenantAndIDRow struct {
	ID         uuid.UUID
	TenantID   uuid.UUID
	Type       PaymentMethodType
	Label      string
	IsDefault  bool
	CreatedAt  time.Time
	ModifiedAt time.Time
}

func (q *Queries) GetPaymentMethodByTenantAndID(ctx context.Context, arg GetPaymentMethodByTenantAndIDParams) (GetPaymentMethodByTenantAndIDRow, error) {
	row := q.db.QueryRow(ctx, getPaymentMethodByTenantAndID, arg.TenantID, arg.ID)
	var i GetPaymentMethodByTenantAndIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Type,
		&i.Label,
		&i.IsDefault,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const listPaymentMethodsByTenant = `-- name: ListPaymentMethodsByTenant :many
SELECT "id", "tenant_id", "type", "label", "is_default", "created_at", "modified_at"
FROM "payment_method"
WHERE "tenant_id" = $1
  AND "deleted_at" IS NULL
ORDER BY "is_default" DESC, "created_at" ASC
`

type ListPaymentMethodsByTenantRow struct {
	ID         uuid.UUID
	TenantID   uuid.UUID
	Type       PaymentMethodType
	Label      string
	IsDefault  bool
	CreatedAt  time.Time
	ModifiedAt time.Time
}

func (q *Queries) ListPaymentMethodsByTenant(ctx context.Context, tenantID uuid.UUID) ([]ListPaymentMethodsByTenantRow, error) {
	rows, err := q.db.Query(ctx, listPaymentMethodsByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPaymentMethodsByTenantRow{}
	for rows.Next() {
		var i ListPaymentMethodsByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Type,
			&i.Label,
			&i.IsDefault,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
