// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: order.sql

package pgsqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countCartItemsByTenantAndCart = `-- name: CountCartItemsByTenantAndCart :one
SELECT COUNT(*)::INT
FROM "cart_item"
WHERE "tenant_id" = $1
  AND "cart_id" = $2
  AND "deleted_at" IS NULL
`

type CountCartItemsByTenantAndCartParams struct {
	TenantID uuid.UUID
	CartID   uuid.UUID
}

func (q *Queries) CountCartItemsByTenantAndCart(ctx context.Context, arg CountCartItemsByTenantAndCartParams) (int32, error) {
	row := q.db.QueryRow(ctx, countCartItemsByTenantAndCart, arg.TenantID, arg.CartID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO "order" (
    "tenant_id",
    "user_uid",
    "cart_id",
    "status",
    "fulfillment_type",
    "delivery_address_line",
    "delivery_city",
    "delivery_lat",
    "delivery_lng",
    "subtotal",
    "tax",
    "total"
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12
)
RETURNING "id", "tenant_id", "user_uid", "cart_id", "status", "fulfillment_type", "subtotal", "tax", "total", "created_at", "modified_at"
`

type CreateOrderParams struct {
	TenantID            uuid.UUID
	UserUid             uuid.UUID
	CartID              uuid.UUID
	Status              OrderStatus
	FulfillmentType     FulfillmentType
	DeliveryAddressLine pgtype.Text
	DeliveryCity        pgtype.Text
	DeliveryLat         pgtype.Numeric
	DeliveryLng         pgtype.Numeric
	Subtotal            int64
	Tax                 int64
	Total               int64
}

type CreateOrderRow struct {
	ID              uuid.UUID
	TenantID        uuid.UUID
	UserUid         uuid.UUID
	CartID          uuid.UUID
	Status          OrderStatus
	FulfillmentType FulfillmentType
	Subtotal        int64
	Tax             int64
	Total           int64
	CreatedAt       time.Time
	ModifiedAt      time.Time
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (CreateOrderRow, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.TenantID,
		arg.UserUid,
		arg.CartID,
		arg.Status,
		arg.FulfillmentType,
		arg.DeliveryAddressLine,
		arg.DeliveryCity,
		arg.DeliveryLat,
		arg.DeliveryLng,
		arg.Subtotal,
		arg.Tax,
		arg.Total,
	)
	var i CreateOrderRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserUid,
		&i.CartID,
		&i.Status,
		&i.FulfillmentType,
		&i.Subtotal,
		&i.Tax,
		&i.Total,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO "order_item" (
    "tenant_id",
    "order_id",
    "product_id",
    "quantity",
    "unit_price",
    "vat_percent",
    "line_total",
    "note",
    "prescription_ref"
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9
)
RETURNING "id", "tenant_id", "order_id", "product_id", "quantity", "unit_price", "vat_percent", "line_total", "note", "prescription_ref", "created_at"
`

type CreateOrderItemParams struct {
	TenantID        uuid.UUID
	OrderID         uuid.UUID
	ProductID       uuid.UUID
	Quantity        int32
	UnitPrice       int64
	VatPercent      pgtype.Numeric
	LineTotal       int64
	Note            pgtype.Text
	PrescriptionRef pgtype.Text
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.TenantID,
		arg.OrderID,
		arg.ProductID,
		arg.Quantity,
		arg.UnitPrice,
		arg.VatPercent,
		arg.LineTotal,
		arg.Note,
		arg.PrescriptionRef,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.UnitPrice,
		&i.VatPercent,
		&i.LineTotal,
		&i.Note,
		&i.PrescriptionRef,
		&i.CreatedAt,
	)
	return i, err
}

const getCartByTenantAndID = `-- name: GetCartByTenantAndID :one
SELECT "id", "tenant_id", "user_uid", "is_active", "created_at", "modified_at"
FROM "cart"
WHERE "tenant_id" = $1
  AND "id" = $2
  AND "is_active" = TRUE
LIMIT 1
`

type GetCartByTenantAndIDParams struct {
	TenantID uuid.UUID
	ID       uuid.UUID
}

func (q *Queries) GetCartByTenantAndID(ctx context.Context, arg GetCartByTenantAndIDParams) (Cart, error) {
	row := q.db.QueryRow(ctx, getCartByTenantAndID, arg.TenantID, arg.ID)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserUid,
		&i.IsActive,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const getOrderByTenantAndID = `-- name: GetOrderByTenantAndID :one
SELECT "id", "tenant_id", "user_uid", "cart_id", "status", "fulfillment_type", "subtotal", "tax", "total", ("paid_at" IS NOT NULL)::bool AS "is_paid", "created_at", "modified_at"
FROM "order"
WHERE "tenant_id" = $1
  AND "id" = $2
  AND "deleted_at" IS NULL
LIMIT 1
`

type GetOrderByTenantAndIDParams struct {
	TenantID uuid.UUID
	ID       uuid.UUID
}

type GetOrderByTenantAndIDRow struct {
	ID              uuid.UUID
	TenantID        uuid.UUID
	UserUid         uuid.UUID
	CartID          uuid.UUID
	Status          OrderStatus
	FulfillmentType FulfillmentType
	Subtotal        int64
	Tax             int64
	Total           int64
	IsPaid          bool
	CreatedAt       time.Time
	ModifiedAt      time.Time
}

func (q *Queries) GetOrderByTenantAndID(ctx context.Context, arg GetOrderByTenantAndIDParams) (GetOrderByTenantAndIDRow, error) {
	row := q.db.QueryRow(ctx, getOrderByTenantAndID, arg.TenantID, arg.ID)
	var i GetOrderByTenantAndIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserUid,
		&i.CartID,
		&i.Status,
		&i.FulfillmentType,
		&i.Subtotal,
		&i.Tax,
		&i.Total,
		&i.IsPaid,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const listCartItemsByTenantAndCart = `-- name: ListCartItemsByTenantAndCart :many
SELECT "id", "tenant_id", "cart_id", "product_id", "quantity", "unit_price", "vat_percent", "note", "prescription_ref", "created_at", "modified_at"
FROM "cart_item"
WHERE "tenant_id" = $1
  AND "cart_id" = $2
  AND "deleted_at" IS NULL
ORDER BY "created_at" ASC
`

type ListCartItemsByTenantAndCartParams struct {
	TenantID uuid.UUID
	CartID   uuid.UUID
}

type ListCartItemsByTenantAndCartRow struct {
	ID              uuid.UUID
	TenantID        uuid.UUID
	CartID          uuid.UUID
	ProductID       uuid.UUID
	Quantity        int32
	UnitPrice       int64
	VatPercent      pgtype.Numeric
	Note            pgtype.Text
	PrescriptionRef pgtype.Text
	CreatedAt       time.Time
	ModifiedAt      time.Time
}

func (q *Queries) ListCartItemsByTenantAndCart(ctx context.Context, arg ListCartItemsByTenantAndCartParams) ([]ListCartItemsByTenantAndCartRow, error) {
	rows, err := q.db.Query(ctx, listCartItemsByTenantAndCart, arg.TenantID, arg.CartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCartItemsByTenantAndCartRow{}
	for rows.Next() {
		var i ListCartItemsByTenantAndCartRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CartID,
			&i.ProductID,
			&i.Quantity,
			&i.UnitPrice,
			&i.VatPercent,
			&i.Note,
			&i.PrescriptionRef,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markOrderPaidByTenant = `-- name: MarkOrderPaidByTenant :one
UPDATE "order"
SET "payment_method_id" = $3,
    "paid_at" = CURRENT_TIMESTAMP,
    "modified_at" = CURRENT_TIMESTAMP
WHERE "tenant_id" = $1
  AND "id" = $2
  AND "deleted_at" IS NULL
  AND "paid_at" IS NULL
RETURNING "id", "tenant_id", "user_uid", "cart_id", "status", "fulfillment_type", "subtotal", "tax", "total", TRUE AS "is_paid", "created_at", "modified_at"
`

type MarkOrderPaidByTenantParams struct {
	TenantID        uuid.UUID
	ID              uuid.UUID
	PaymentMethodID uuid.UUID
}

type MarkOrderPaidByTenantRow struct {
	ID              uuid.UUID
	TenantID        uuid.UUID
	UserUid         uuid.UUID
	CartID          uuid.UUID
	Status          OrderStatus
	FulfillmentType FulfillmentType
	Subtotal        int64
	Tax             int64
	Total           int64
	IsPaid          bool
	CreatedAt       time.Time
	ModifiedAt      time.Time
}

func (q *Queries) MarkOrderPaidByTenant(ctx context.Context, arg MarkOrderPaidByTenantParams) (MarkOrderPaidByTenantRow, error) {
	row := q.db.QueryRow(ctx, markOrderPaidByTenant, arg.TenantID, arg.ID, arg.PaymentMethodID)
	var i MarkOrderPaidByTenantRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserUid,
		&i.CartID,
		&i.Status,
		&i.FulfillmentType,
		&i.Subtotal,
		&i.Tax,
		&i.Total,
		&i.IsPaid,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const setCartInactive = `-- name: SetCartInactive :exec
UPDATE "cart"
SET "is_active" = FALSE,
    "modified_at" = CURRENT_TIMESTAMP
WHERE "tenant_id" = $1
  AND "id" = $2
`

type SetCartInactiveParams struct {
	TenantID uuid.UUID
	ID       uuid.UUID
}

func (q *Queries) SetCartInactive(ctx context.Context, arg SetCartInactiveParams) error {
	_, err := q.db.Exec(ctx, setCartInactive, arg.TenantID, arg.ID)
	return err
}

const updateOrderStatusByTenant = `-- name: UpdateOrderStatusByTenant :one
UPDATE "order"
SET "status" = $3,
    "cancelled_at" = CASE WHEN $4::BOOL THEN CURRENT_TIMESTAMP ELSE "cancelled_at" END,
    "refunded_at" = CASE WHEN $5::BOOL THEN CURRENT_TIMESTAMP ELSE "refunded_at" END,
    "modified_at" = CURRENT_TIMESTAMP
WHERE "tenant_id" = $1
  AND "id" = $2
  AND "deleted_at" IS NULL
RETURNING "id", "tenant_id", "user_uid", "cart_id", "status", "fulfillment_type", "subtotal", "tax", "total", ("paid_at" IS NOT NULL)::bool AS "is_paid", "created_at", "modified_at"
`

type UpdateOrderStatusByTenantParams struct {
	TenantID uuid.UUID
	ID       uuid.UUID
	Status   OrderStatus
	Column4  bool
	Column5  bool
}

type UpdateOrderStatusByTenantRow struct {
	ID              uuid.UUID
	TenantID        uuid.UUID
	UserUid         uuid.UUID
	CartID          uuid.UUID
	Status          OrderStatus
	FulfillmentType FulfillmentType
	Subtotal        int64
	Tax             int64
	Total           int64
	IsPaid          bool
	CreatedAt       time.Time
	ModifiedAt      time.Time
}

func (q *Queries) UpdateOrderStatusByTenant(ctx context.Context, arg UpdateOrderStatusByTenantParams) (UpdateOrderStatusByTenantRow, error) {
	row := q.db.QueryRow(ctx, updateOrderStatusByTenant,
		arg.TenantID,
		arg.ID,
		arg.Status,
		arg.Column4,
		arg.Column5,
	)
	var i UpdateOrderStatusByTenantRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserUid,
		&i.CartID,
		&i.Status,
		&i.FulfillmentType,
		&i.Subtotal,
		&i.Tax,
		&i.Total,
		&i.IsPaid,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}
