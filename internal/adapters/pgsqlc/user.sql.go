// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: user.sql

package pgsqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one
INSERT INTO "user" (
	"tenant_id"
	, "role"
	, "email"
	, "password"
	, "full_name"
	, "is_staff"
	, "is_active"
	, "last_login"
	)
VALUES (
	$1
	, $2
	, $3
	, $4
	, $5
	, $6
	, $7
	, $8
	) RETURNING "uid"
	, "tenant_id"
	, "email"
	, "full_name"
	, "created_at"
	, "modified_at"
`

type CreateUserParams struct {
	TenantID  uuid.UUID
	Role      UserRole
	Email     string
	Password  string
	FullName  string
	IsStaff   bool
	IsActive  bool
	LastLogin time.Time
}

type CreateUserRow struct {
	UID        uuid.UUID
	TenantID   uuid.UUID
	Email      string
	FullName   string
	CreatedAt  time.Time
	ModifiedAt time.Time
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.TenantID,
		arg.Role,
		arg.Email,
		arg.Password,
		arg.FullName,
		arg.IsStaff,
		arg.IsActive,
		arg.LastLogin,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.UID,
		&i.TenantID,
		&i.Email,
		&i.FullName,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const getUserByTenantAndEmail = `-- name: GetUserByTenantAndEmail :one
SELECT
	"id",
	"tenant_id",
	"role",
	"uid",
	"email",
	"password",
	"full_name",
	"is_staff",
	"is_active",
	COALESCE("last_login", CURRENT_TIMESTAMP) AS "last_login",
	"created_at",
	"modified_at"
FROM "user"
WHERE "tenant_id" = $1
	AND "email" = $2
	AND "deleted_at" IS NULL
LIMIT 1
`

type GetUserByTenantAndEmailParams struct {
	TenantID uuid.UUID
	Email    string
}

type GetUserByTenantAndEmailRow struct {
	ID         int64
	TenantID   uuid.UUID
	Role       UserRole
	UID        uuid.UUID
	Email      string
	Password   string
	FullName   string
	IsStaff    bool
	IsActive   bool
	LastLogin  time.Time
	CreatedAt  time.Time
	ModifiedAt time.Time
}

func (q *Queries) GetUserByTenantAndEmail(ctx context.Context, arg GetUserByTenantAndEmailParams) (GetUserByTenantAndEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByTenantAndEmail, arg.TenantID, arg.Email)
	var i GetUserByTenantAndEmailRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Role,
		&i.UID,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.IsStaff,
		&i.IsActive,
		&i.LastLogin,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const getUserByTenantAndUID = `-- name: GetUserByTenantAndUID :one
SELECT
	"id",
	"tenant_id",
	"role",
	"uid",
	"email",
	"password",
	"full_name",
	"is_staff",
	"is_active",
	COALESCE("last_login", CURRENT_TIMESTAMP) AS "last_login",
	"created_at",
	"modified_at"
FROM "user"
WHERE "tenant_id" = $1
	AND "uid" = $2
	AND "deleted_at" IS NULL
LIMIT 1
`

type GetUserByTenantAndUIDParams struct {
	TenantID uuid.UUID
	UID      uuid.UUID
}

type GetUserByTenantAndUIDRow struct {
	ID         int64
	TenantID   uuid.UUID
	Role       UserRole
	UID        uuid.UUID
	Email      string
	Password   string
	FullName   string
	IsStaff    bool
	IsActive   bool
	LastLogin  time.Time
	CreatedAt  time.Time
	ModifiedAt time.Time
}

func (q *Queries) GetUserByTenantAndUID(ctx context.Context, arg GetUserByTenantAndUIDParams) (GetUserByTenantAndUIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByTenantAndUID, arg.TenantID, arg.UID)
	var i GetUserByTenantAndUIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Role,
		&i.UID,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.IsStaff,
		&i.IsActive,
		&i.LastLogin,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}
